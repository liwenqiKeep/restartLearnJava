[toc]
# 设计模式总结
[代码示例项目](../../05_面试&算法题集/LeetCode/src/main/java/com/lwq/designPattern)

   优秀博客分享
    [代理模式和装饰器模式](http://www.360doc.com/content/22/0422/12/64417993_1027728137.shtml)
## 代理模式

* **静态代理**

    
    
    静态代理就是将目标类设置为代理类的一个属性，并且在代理方法中加入目标类需要增强的行为（方法）。静态代理由于其固定性，因此在项目中，使用场景较少。代理模式的代码结构与策略模式有一定的共性，可以类比。
            
        /**
        * 静态代理
        */
        class StaticProxy {
            private final StaticProxyInterface proxyInterface;

            public StaticProxy(StaticProxyInterface proxyInterface) {
                this.proxyInterface = proxyInterface;
            }

            public void test() {
                System.out.println("代理类开始执行");
                proxyInterface.test();
                System.out.println("代理类结束执行");
            }
        }

        interface StaticProxyInterface {

            /**
            * 静态代理测试接口
            */
            void test();

        }

        class StaticProxyImplement implements StaticProxyInterface {

            /**
            * 静态代理测试接口
            */
            @Override
            public void test() {
                System.out.println("成功代理");
            }
        }

* **JDK动态代理**
    实现步骤：
    * 将目标类设置到代理类的属性中
    * 代理类实现 InvocationHandler 接口的 invoke() 方法
        
            /**
            * jdk 动态代理
            */
            interface DynamicProxyInterface{
                /**
                * 代理测试接口
                */
                void test();
            }

            class DynamicProxyImplement implements DynamicProxyInterface {

                /**
                * 静态代理测试接口
                */
                @Override
                public void test() {
                    System.out.println("成功代理");
                }
            }

            class DynamicProxyInvocationHandler<T> implements InvocationHandler{

                T target;
                public  DynamicProxyInvocationHandler(T target) {
                    this.target = target;
                }
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                    System.out.println("Dynamic proxy invoke");
                    return method.invoke(target,args);
                }
            }        


    *  通过 `java.lang.reflect.Proxy` 获取代理类实现的接口，并调用相关方法

            private static void executeJdkDynamicProxy() {
                DynamicProxyInterface proxy = new DynamicProxyImplement();

                InvocationHandler handler = new DynamicProxyInvocationHandler<>(proxy);

                DynamicProxyInterface executeProxy =
                        (DynamicProxyInterface) java.lang.reflect.Proxy.newProxyInstance(
                                proxy.getClass().getClassLoader(),
                                new Class[]{DynamicProxyInterface.class},
                                handler
                        );
                executeProxy.test();

            }
源码分析  `java.lang.reflect.Proxy`

* **cjlib动态代理**

* **代理模式测试类**

        

        import net.sf.cglib.proxy.Enhancer;
        import net.sf.cglib.proxy.MethodInterceptor;
        import net.sf.cglib.proxy.MethodProxy;

        import java.lang.reflect.InvocationHandler;
        import java.lang.reflect.Method;

        /**
        * 代理模式
        *
        */
        public class Proxy {

            public static void main(String[] args) {
                System.out.println("静态代理开始执行");
                executeStaticProxy();

                System.out.println("\r\njdk动态代理开始执行");
                executeJdkDynamicProxy();

                System.out.println("\r\ncglib动态代理开始执行");
                executeCglibDynamicProxy();
            }

            private static void executeCglibDynamicProxy() {
                CglibProxy<CglibTarget> proxy = new CglibProxy<>(new CglibTarget());
                CglibTarget target = (CglibTarget) proxy.getProxy();
                target.test();
            }

            private static void executeJdkDynamicProxy() {
                DynamicProxyInterface proxy = new DynamicProxyImplement();

                InvocationHandler handler = new DynamicProxyInvocationHandler<>(proxy);

                DynamicProxyInterface executeProxy =
                        (DynamicProxyInterface) java.lang.reflect.Proxy.newProxyInstance(
                                proxy.getClass().getClassLoader(),
                                new Class[]{DynamicProxyInterface.class},
                                handler
                        );
                executeProxy.test();

            }

            private static void executeStaticProxy() {
                StaticProxy proxy = new StaticProxy(new StaticProxyImplement());
                proxy.test();
            }

        }

        /**
        * 静态代理
        */
        class StaticProxy {
            private final StaticProxyInterface proxyInterface;

            public StaticProxy(StaticProxyInterface proxyInterface) {
                this.proxyInterface = proxyInterface;
            }

            public void test() {
                System.out.println("代理类开始执行");
                proxyInterface.test();
                System.out.println("代理类结束执行");
            }
        }

        interface StaticProxyInterface {

            /**
            * 静态代理测试接口
            */
            void test();

        }

        class StaticProxyImplement implements StaticProxyInterface {

            /**
            * 静态代理测试接口
            */
            @Override
            public void test() {
                System.out.println("成功代理");
            }
        }

        /**
        * jdk 动态代理
        */
        interface DynamicProxyInterface{
            /**
            * 代理测试接口
            */
            void test();
        }

        class DynamicProxyImplement implements DynamicProxyInterface {

            /**
            * 静态代理测试接口
            */
            @Override
            public void test() {
                System.out.println("成功代理");
            }
        }

        class DynamicProxyInvocationHandler<T> implements InvocationHandler{

            T target;
            public  DynamicProxyInvocationHandler(T target) {
                this.target = target;
            }
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                System.out.println("Dynamic proxy invoke");
                return method.invoke(target,args);
            }
        }

        /**
        * cglib 动态代理
        *
        */
        class CglibTarget{
            public void test(){
                System.out.println("目标类执行");
            }
        }

        class CglibProxy<T> implements MethodInterceptor{

            T target;
            public  CglibProxy(T target){
                this.target = target;
            }

            public Object getProxy(){
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(target.getClass());
                enhancer.setCallback(this);
                return enhancer.create();
            }
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println("代理前增强");
                Object end = methodProxy.invoke(target,objects);
                System.out.println("代理后增强");
                return end;
            }
        }



## 策略模式
示例代码



        /**
        * 策略模式
        */
        public class Strategy {

            public static void main(String[] args) {
                Context context = new Context(new Dog());
                context.call();


                Context context2 = new Context(() -> System.out.println("嘻嘻嘻"));
                context2.call();
            }
        }


        interface Animal{
            /**
            * 叫
            */
            void call();
        }

        class Cat implements Animal{

            /**
            * 叫
            */
            @Override
            public void call() {
                System.out.println("喵喵喵");
            }
        }

        class Dog implements Animal{

            /**
            * 叫
            */
            @Override
            public void call() {
                System.out.println("汪汪汪");
            }
        }

        class Context {
            private final Animal animal;
            public Context(Animal animal){
                this.animal = animal;
            }

            public void call(){
                this.animal.call();
            }
        }